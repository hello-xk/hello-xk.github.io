---
layout: post
title: 完全二叉树的应用，堆与堆排序
categories: 算法
date: 2017-01-30 12:51:04
pid: 20170130-125104
# you can override the settings in _config.yml here !!
---
完全二叉树的应用 — 堆

{% include toc %}
## 堆
堆是一种特殊的完全二叉树。
![heap][heap]

**最小堆**：完全二叉树中，父结点都比子结点小。最小堆的根结点是最小的。
**最大堆**：完全二叉树中，父结点都比子结点大。最大堆的根结点是最大的。

像上面的图，根结点是最小的，且所有父结点都比子结点小，所以是最小堆。

但，**注意**，堆只是约束了父子结点，并没有约束兄弟结点、无关结点的大小，也即是说，除父子结点外，其它结点之间的大小无法确定。比如，下面的最小堆，只能保证根结点是最小的，并不能确定第二小的结点是哪个，第三小的结点是哪个（不过，可以保证，第二小的要么是根结点的左儿子，要么是根结点的右儿子）。
![min-heap][min-heap]


## 堆排序
很明显的，上面的完全二叉树根结点要么是最大的，要么是最小的，而且父子结点间有次序，那么是否可以应用于排序？

### 查找最小值（最大值）
假如有7个数：7 4 2 5 6 3 1，请找出最小的数。

直观的做法是使用**擂台法**（选其中一个数作为最小数放到擂台，剩余的数依次和擂台上的值比较，更小的留在擂台，最后留在擂台的就是最小值）。

```
int a[] = {7, 4, 2, 5, 6, 3, 1};
int min = a[0];
for (int i = 1; i < 7; ++i)
{
  if (a[i] < min)
  {
    min = a[i];
  }
}
```
这种算法从头到尾扫一遍数组，执行了6次比较，所以时间复杂度是O(6)，即O(N-1)，即O(N)的时间复杂度。

上面的数组：`7 4 2 5 6 3 1` 转换为完全二叉树，结果如下图
![heap-tree][heap-tree]

要找到最小的数，将完全二叉树转换为最小堆，那么根结点就是最小的数。

**一个完全二叉树要转换为最小堆，有多少度就需要比较多少次**。比如，上面的二叉树，需要比较`4/5=4 4/6=4 2/3=2 2/1=1 7/4=4 4/1=1`共6次才能完成最小堆（注：4/5=4表示父结点4与子结点5比较，结果父结点为4的意思）。可见，堆排序的时间复杂度和上面的擂台法时间复杂度都是O(N)。

**所以**，找最小值（最大值）至少都要比较N-1次，各种算法没有太明显的优劣，时间复杂度都是O(N)。也即是说，如果只是找最小值（最大值）可以放心使用简单的擂台法。

### 查找最小的（最大的）N个值
假如有7个数：7 4 2 5 6 3 1，请找出最小的3个数。

**擂台法**
需要比较：6、5、4共15次。即`(N-1)+(N-2)+(N-3)....+(N-n)`次。时间复杂度接近O(N*N)。

**最小堆**
需要比较：6、2、1共9次。时间复杂度没计算。只是简单讨论一下为什么堆排序再次查找的时候为什么会更快。
![heap-sort][heap-sort]

如图，第一次是因为要初始化最小堆，所以需要进行N-1次比较，当最小堆建立后，再次查找就能利用最小堆的特性：父结点总比子结点小。所以**根结点的左儿子是左子树最小的，根结点的右儿子是右子树最小的**。只需要比较这两个儿子，就能确定第2小的数值。不过，通常不是这样做，而是先把根结点移除后，重新调整最小堆，然后新的最小堆的根结点就是第2小了。然后再把根结点移除，重新调整最小堆，这样新的最小堆的根结点就是第3小，以此类推，每次移走根结点，重新调整最小堆。`这里没有讨论移除根结点重新调整最小堆的效率问题，通常调整最小堆需要对数组的元素进行移动`

[heap]: {{ site.images_url }}algorithm/heap/heap.jpg
[min-heap]: {{ site.images_url }}algorithm/heap/min-heap.jpg
[heap-tree]: {{ site.images_url }}algorithm/heap/heap-tree.jpg
[heap-sort]: {{ site.images_url }}algorithm/heap/heap-sort.jpg
