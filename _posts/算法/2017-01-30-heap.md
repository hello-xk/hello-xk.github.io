---
layout: post
title: 完全二叉树的应用，堆与堆排序
categories: 算法
date: 2017-01-30 12:51:04
pid: 20170130-125104
# you can override the settings in _config.yml here !!
---
完全二叉树的应用 — 堆

{% include toc %}
## 堆
堆是一种特殊的完全二叉树，**只有最小堆和最大堆**。
![heap][heap]

**最小堆**：完全二叉树中，父结点都比子结点小。最小堆的根结点是最小的。
**最大堆**：完全二叉树中，父结点都比子结点大。最大堆的根结点是最大的。

最小堆的子树也是最小堆，同理，最大堆的子树也是最大堆。

像上面的图，根结点是最小的，且所有父结点都比子结点小，所以是最小堆。

但，**注意**，堆只是约束了父子结点，并没有约束兄弟结点、无关结点的大小，也即是说，除父子结点外，其它结点之间的大小无法确定。比如，下面的最小堆，只能保证根结点是最小的，并不能确定第二小的结点是哪个，第三小的结点是哪个（不过，可以保证，第二小的要么是根结点的左儿子，要么是根结点的右儿子，因为子树是最小堆，子子树也是最小堆）。
![min-heap][min-heap]

## 堆的初始化
很明显的，上面的完全二叉树根结点要么是最大的，要么是最小的，而且父子结点间有次序，那么是否可以应用于排序？

### 查找最小值（最大值）
假如有7个数：7 4 2 5 6 3 1，请找出最小的数。

直观的做法是使用**擂台法**（选其中一个数作为最小数放到擂台，剩余的数依次和擂台上的值比较，更小的留在擂台，最后留在擂台的就是最小值）。

```c
int a[] = {7, 4, 2, 5, 6, 3, 1};
int length = sizeof(a)/sizeof(a[0]);
int min = a[0];
for (int i = 1; i < length; ++i)
{
  if (a[i] < min)
  {
    min = a[i];
  }
}
// without test
```
这种算法从头到尾扫一遍数组，执行了6次比较，所以时间复杂度是O(6)，即O(N-1)，即O(N)的时间复杂度。

还可以使用**冒泡法**

```c
int a[] = {7, 4, 2, 5, 6, 3, 1};
int length = sizeof(a)/sizeof(a[0]);
for (int l = length-2, r = length-1; l >= 0; --l, --r)
{
  if (a[l] >= a[r])
  {
    a[l] = a[l] ^ a[r]; // 经典的异或交换算法
    a[r] = a[l] ^ a[r];
    a[l] = a[l] ^ a[r];
  }
}
// without test
```
冒泡法也要执行N-1次比较。

上面的数组：`7 4 2 5 6 3 1` 转换为完全二叉树，结果如下图
![heap-tree][heap-tree]

要找到最小的数，将完全二叉树转换为最小堆，那么根结点就是最小的数。

上面的二叉树，需要比较`5/6=5 5/4=4 不换, 3/1=1 1/2=1 换, 4/1=1 1/7=1 换`共6次才能完成得到最小值（注：5/6=5 5/4=4 不换 表示兄弟结点5、6比较，然后和父结点4比较，结果为不需交换的意思）。可见，找最小值，堆排序的时间复杂度和上面的擂台法时间复杂度都是O(N)。

**然而，得到最小值后，堆还不是最小堆**！！，因为上面交换下来的值，需要逐层下沉，就像上面的`结点1`与`结点7`交换了，`结点7`还需要和下面的儿子`结点2`、`结点3`比较，继续下沉。上面没有处理继续下沉的情况，因为求最小值不需要继续下沉。但是如果要建立最小堆，必须考虑递归下沉的情况，这里可以看到，**一个完全二叉树要转换为最小堆，需要遍历子树，所以是比较耗费时间的**，这也是为什么说，数量少的排序，不适宜使用堆排序，因为最小堆（最大堆）的初次建立要耗费比较多的时间。

**从上也可见**，找最小值（最大值）至少都要比较N-1次，各种算法没有太明显的优劣，时间复杂度都是O(N)。也即是说，如果只是找最小值（最大值）可以放心使用简单的擂台法，不需要交换元素的值。

### 查找最小的（最大的）N个值
假如有7个数：7 4 2 5 6 3 1，请找出最小的3个数。

**擂台法**
需要比较：6、5、4共15次。即`(N-1)+(N-2)+(N-3)....+(N-n)`次。时间复杂度接近O(N*N)。

**冒泡法**
冒泡法和擂台法一样。

**最小堆**
需要比较：6+x、2、1共9+x次（x表示建立最小堆需要的未知次数）。时间复杂度没计算。只是简单讨论一下堆排序再次查找的时候为什么会更快。
![min-heap-convert][min-heap-convert]

如图，第一次是因为要初始化最小堆，所以需要进行`N-1+x`次比较，当最小堆建立后，再次查找就能利用最小堆的特性：父结点总比子结点小。所以**根结点的左儿子是左子树最小的，根结点的右儿子是右子树最小的**。只需要比较这两个儿子，就能确定第2小的数值。不过，通常不是这样做，而是先把根结点移除后，重新调整最小堆，然后新的最小堆的根结点就是第2小了。然后再把根结点移除，重新调整最小堆，这样新的最小堆的根结点就是第3小，以此类推，每次移走根结点，重新调整最小堆。`这里没有讨论移除根结点重新调整最小堆的效率问题，通常调整最小堆需要对数组的元素进行移动`

### 最小堆（最大堆）算法
将一个数组序列转换为最小堆（最大堆）。

主要要点：

1. 如果当前结点为`k`，那么左儿子为`2*k+1`，右儿子为`2*k+2`。
2. 先比较两个儿子结点，更小（更大）的才和当前结点比较，这样就能决定哪个儿子需要和当前结点交换。
3. 遍历可以从非叶子结点开始，假如结点数为n，那么非叶子结点的数量为`(int)n/2`（二叉树，两个结点可以组成一个非叶子结点）。
4. 结点的儿子结点不能超出数组下标，超出说明该结点是叶子结点。所以访问儿子结点时，需要先判断儿子的下标是否超出数组长度！！（除非已经确保了不会越界）。
5. 进行了交换的结点，需要循环检查到叶子结点，因为可能还需要继续下沉（遇到叶子结点的依据是儿子下标越界）。
6. 交换前进行的判断，符号决定了堆是最小堆还是最大堆（更改符号即能从最小堆转换为最大堆）。

下面是一些最小堆的建立算法

```c
int a[] = {7, 4, 2, 5, 6, 3, 1};
int length = sizeof(a)/sizeof(a[0]);
// 从最后一个非叶子结点开始遍历
for (int i = length/2-1; i >= 0; --i)
{
  int lchild = i * 2 + 1;
  int rchild = lchild + 1;
  // 不合法表示是叶子结点，合法表示含有左右儿子
  while (rchild < length) { // 循环是因为下沉的结点可能会继续下沉到最后
    if (a[i] <= a[lchild] && a[i] <= a[rchild]) {
      break;
    }
    if (a[lchild] <= a[rchild]) { // 左儿子比结点小 （到达这里，说明结点比左、右其中一个儿子大。也即是说，最小的是左、右儿子其中一个
      a[lchild] = a[lchild] ^ a[i];
           a[i] = a[lchild] ^ a[i];
      a[lchild] = a[lchild] ^ a[i];
      i = lchild;
    } else {  // 右儿子比结点小
      a[rchild] = a[rchild] ^ a[i];
           a[i] = a[rchild] ^ a[i];
      a[rchild] = a[rchild] ^ a[i];
      i = rchild;
    }
    lchild = i * 2 + 1;
    rchild = lchild + 1;
  }
  // 不合法表示是叶子结点，合法表示只有左儿子（如果还有右儿子就进入上面了
  if (lchild < length)
  {
    if (a[lchild] < a[i]) {   // 左儿子比结点小
      a[lchild] = a[lchild] ^ a[i];
           a[i] = a[lchild] ^ a[i];
      a[lchild] = a[lchild] ^ a[i];
    }
  }
}
// without test
```
简化版

```c
int a[] = {7, 4, 2, 5, 6, 3, 1};
int length = sizeof(a)/sizeof(a[0]);
// 从最后一个非叶子结点开始遍历
for (int i = length/2-1; i >= 0; --i)
{
  int nth;  // 准备下沉的位置
  for (int j = i; 2 * j  + 1 < length; j = nth) {
    // 得到儿子中较大的那个
    nth = 2 * j + 1;
    if (nth < length - 1 && a[nth + 1] < a[nth]) {
      ++nth;
    }
    // 较大的那个和父结点比较
    if (a[j] > a[nth]) {
      a[nth] = a[nth] ^ a[j];
      a[j] = a[nth] ^ a[j];
      a[nth] = a[nth] ^ a[j];
      // 结点下沉了，需要判断是否需要继续下沉
    } else {
      break;  // 父结点是最小的，不用继续下沉了
    }  
  }
}
// without test
```

#### 循环下沉
像下面，`结点7`和`结点1`交换下沉后，还需要继续和`结点2`交换下沉。当树更深的时候，下沉还会持续，直到最深的一个叶子结点。
![sink][sink]

#### 建立堆的过程
其实建立堆的过程，就是对每个结点执行循环下沉，而叶子结点因为不能再下沉了，所以只需要对非叶子结点执行。当对每个结点都进行了循环下沉，最小堆（最大堆）就建立了。

#### 比较与交换
`结点`、`左儿子`、`右儿子`之间的比较，也即是3个数中求最小值（最大值）。
![child-compare][child-compare]
可以知道，N个数中求最小值，至少需要进行`N - 1`次比较。也即是说，怎样比较，比较的次数都一样。通常习惯的思维是，`结点`与`左儿子`比较，结果再与`右儿子`比较。然而这在代码中并不好做。假如`左儿子`比`结点`小，要立即交换吗？不行，因为如果`右儿子`比`左儿子`更小，那么就浪费了一次交换。反过来也一样，`右儿子`比`结点`小，也不能立即交换。所以，合理的做法是**先比较`左儿子`和`右儿子`，更小的再和`结点`比较交换**。

#### 为什么自底向上
说到自底向上，有点像冒泡法的感觉。为什么自底向上，最简单的，自底向上可以利用建立好的子堆的特性，减少比较的次数（其实好像比较的次数也没减少到，下沉的时候仍旧需要三个数重新比较）。感觉从上而下也是可以的（从上而下可以比喻成上浮）。
![heap-loop][heap-loop]
如图，通常是自底向上`2 - 3 - 7`，感觉`7 - 3 - 2`也是可以的。

#### 下标问题
`for (int i = length/2-1; i >= 0; --i)`
是从最后一个非叶子结点遍历到第一个非叶子结点（非叶子结点总数为`length/2`，遍历下标为`0 ~ length/2-1`，然后是倒序遍历）。

`if (nth < length - 1 && a[nth + 1] < a[nth]) ++nth;`
是先判断右儿子是否存在（非叶子结点，说明至少有左儿子），如果右儿子存在，则比较左儿子和右儿子的大小。如果右儿子不存在，那么当前结点要比较的对象是左儿子。

`for (int j = i; 2 * j  + 1 < length; j = nth)`
继续下沉过程，下标与上面的非叶子结点遍历的下标不一样！！而且，继续下沉的过程，仍旧需要判断儿子下标是否出界（因为下沉过程，无法得到子树的非叶子结点数，所以只能循着儿子分支直到遇到叶子结点，遇到叶子结点表示此次下沉已经到底）。


## 堆排序
上面只是说了堆的建立，要应用到排序还需要进行修改。

通常，堆排序是在建立了最小堆后，移除根结点，然后继续调整最小堆，继续移除根结点...以此类推，直到只剩最后一个元素。
![heap-sort][heap-sort]

堆排序是**不稳定**的排序算法。

从上图可以看到：
1. 如果建立的是**最小堆**，那么得到的序列是**降序**，因为最小的在最后面。
2. 反之如果建立的是**最大堆**，那么得到的序列是**升序**，因为最大的在最后面。
3. 其实无所谓升序降序，因为数组可以从前、后方向遍历。
4. 堆排序是**不稳定**的排序算法。
5. 堆顶的元素发生改变，只需要执行一次调整，即一次循环下沉即能复原。

代码：

```c
void heap_adjust(int a[], int i, int length)
{
  int nth;  // 准备下沉的位置
  for (int j = i; 2 * j  + 1 < length; j = nth) {
    // 得到儿子中较大的那个
    nth = 2 * j + 1;
    if (nth < length - 1 && a[nth + 1] < a[nth]) {
      ++nth;
    }
    // 较大的那个和父结点比较
    if (a[j] > a[nth]) {
      a[nth] = a[nth] ^ a[j];
      a[j] = a[nth] ^ a[j];
      a[nth] = a[nth] ^ a[j];
      // 结点下沉了，需要判断是否需要继续下沉
    } else {
      break;  // 父结点是最小的，不用继续下沉了
    }  
  }
}

void heap_sort(int a[], int length)
{
  // 建立最小堆（只是将循环下沉部分抽离）
  for (int i = length/2 - 1; i >= 0; --i)
  {
    heap_adjust(a, i, length);
  }
  // 第1个元素（i==0)不需要比较
  for (int i = length - 1; i > 0; --i)
  {
    a[i] = a[i] ^ a[0];
    a[0] = a[i] ^ a[0];
    a[i] = a[i] ^ a[0];

    // 最小堆里插入了一个元素，只需要调整一次
    heap_adjust(a, 0, i);
  }
}
// without test
```

#### 往最小堆（最大堆）里插入一个元素
往最小堆（最大堆）里插入一个元素，只需要调整一次，即只需执行一次循环下沉。

#### 所谓堆排序
观察上面所有的代码，**其实建立堆的过程，是对每个非叶子结点执行循环下沉**。
堆顶的元素发生改变，意味着只需要对堆顶的结点重新执行循环下沉。
如果某个结点发生改变，那么只需要对该结点重新执行循环下沉即可（该结点其实是某个子堆的根结点）。
而循环下沉只对非叶子结点有效，因为叶子结点已经下沉到底了。


学习笔记，仅供参考

[heap]: {{ site.images_url }}algorithm/heap/heap.jpg
[min-heap]: {{ site.images_url }}algorithm/heap/min-heap.jpg
[min-heap-convert]: {{ site.images_url }}algorithm/heap/min-heap-convert.jpg
[heap-tree]: {{ site.images_url }}algorithm/heap/heap-tree.jpg
[sink]: {{ site.images_url }}algorithm/heap/sink.jpg
[child-compare]: {{ site.images_url }}algorithm/heap/child-compare.jpg
[heap-loop]: {{ site.images_url }}algorithm/heap/heap-loop.jpg
[heap-sort]: {{ site.images_url }}algorithm/heap/heap-sort.jpg
