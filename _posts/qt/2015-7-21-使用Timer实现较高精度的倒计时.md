---
layout: post
title: 使用Timer实现较高精度的倒计时
tags: [qt]
author: helloxk
mail: 345106552@qq.com
created: 2015-07-21 10:35:00
modified: 2015-07-21 10:35:00
---
#### 背景 
> 通常，实现一个计时或倒计时的功能，我们首先想到的是使用定时器来实现。
> 将定时器的间隔设置为1000ms，然后在触发时对时间进行处理和显示。
> 然而，我们都知道，``定时器并不准确！``
> 在单线程里面，如果业务逻辑稍微有点复杂和频繁，定时器的误差将比较大，这种程度普通人也是可以看到和感受到的。
> 最近，业务上有一个需求，客户端根据服务器返回的时间进行倒计时（精度是秒级），中途，服务器会同步时间。然而，因为客户端的定时器并不准确，每次大概延时几十到几百毫秒，这样在服务器再次同步时间的时候，客户端已经进行了数十次倒计时，误差已经累计延时几秒。服务器同步时间的时候，我们就看到了客户端的时间忽然跨越了几秒。
> 归根到底，是客户端简单地以定时器的1000ms间隔作为1秒时间的流逝，而其实，定时器触发的时候，并不仅仅过去了1秒。
> 所以，我们需要在定时器每次触发的时候，对时间进行修正。

#### 时间修正
  
下面是当时写的三个函数，函数都是在定时器触发时执行的，目的是进行时间修正，返回时钟真正走过的秒数，只有一个是正确的：

```c++
/** 定时器在这里的作用：
 ** 每隔一段时间检查系统时间是否走动超过1秒，定时器的间隔越短，精度越高。
 ** 另外，定时器不一定准确，下一次触发时可能走动超过1秒。
 **/
int GtcTimeCounterWidget::_elapsedSeconds()
{
	//跳跃的时间
	int elapsedSecs = QDateTime::currentMSecsSinceEpoch()/1000 - m_lastMSecs/1000;
	elapsedSecs = elapsedSecs > 0 ? elapsedSecs : 0;

	//更新上一次定时器触发时系统时间
	m_lastMSecs = QDateTime::currentMSecsSinceEpoch();

	return elapsedSecs;
}
```

```c++
int GtcTimeCounterWidget::_elapsedSeconds()
{
	qint64 elapsedMSecs = QDateTime::currentMSecsSinceEpoch() - m_lastMSecs;
	int elapsedSecs = elapsedMSecs > 0 ? elapsedMSecs / 1000 : 0;
	//时间跳跃了至少1秒才更新
	if (elapsedSecs)
	{
		m_lastMSecs = QDateTime::currentMSecsSinceEpoch();//更新上一次定时器触发时系统时间
	}
	return elapsedSecs;
}	
```

```c++
int GtcTimeCounterWidget::_elapsedSeconds()
{
	qint64 elapsedMSecs = QDateTime::currentMSecsSinceEpoch() - m_lastMSecs;
	m_lastMSecs = QDateTime::currentMSecsSinceEpoch();//更新上一次定时器触发时系统时间
	return elapsedMSecs > 0 ? elapsedMSecs / 1000 : 0;
}
```
很明显，第一个函数才是正确的。

第二个函数看起来感觉没什么问题，有点像第一个函数里面的``QDateTime::currentMSecsSinceEpoch()/1000 - m_lastMSecs/1000``进行数学运算法则的变换：``(QDateTime::currentMSecsSinceEpoch() - m_lastMSecs)/1000``，如果代码看多了，或者一时粗心，可能就真认为上述是等价的。从想法上面去理解，前者是两个时间的秒数相减，后者是两个时间相差的秒数。乍一看，好像还是一样，但其实它们不等价，原因是精度不同。前者的精度是秒级，后者的精度是毫秒级。10.99s和10.00s如果在秒级精度，它们是相等的，而如果在毫秒级精度，它们是不等的。再如11s和10.99s，按第一个算法结果是1，而第二个算法结果是0，结果也不一样。

第二个函数更像是定时器间隔是1000ms的变种，而且误差更加大。这些函数里，最关键的两个变量是``m_lastMSecs``和``QDateTime::currentMSecsSinceEpoch()``，分别对应上一个时刻和当前时刻。第二个函数里对跳跃的时间进行判断才更新上一个时刻，更像是使用定时器去实现另一个定时器。

第三个函数更可笑，既然在定时器里触发，``elapsedMSecs``当然和定时器的间隔差不多，为了修正定时器的误差，这个定时器必须比1000ms要小，所以``return elapsedMSecs > 0 ? elapsedMSecs / 1000 : 0;``语句总是返回0，换言之时间就不动了。

重新梳理一下思路。为了修正时间，在定时器触发时，我们不能以定时器的间隔作为时间的流逝，我们必须获取到真实的时间。在客户端，其中一种途径是获取系统的时间。接着，我们需要“感知”时间的流动。为此，我们使用间隔低于1000ms的定时器来不停地“检查”时间是否跳动了1秒（注：是“检查”秒针是否跳动了，而不是获取真正流逝的时间，正因为不明确这一点才导致第二第三这些函数的出现）。于是，当系统的时间跳动了1秒后，若干毫秒后，我们就能检测到，继而修改我们的倒计时。这个精度取决于我们的定时器的间隔，如果我们的定时器间隔是100ms，那么最差的情况下，系统时间跳动了1秒后，100ms后我们就能检测到。

然而，这是理想的情况，永远记得，定时器是不准确的！系统时间跳动1秒后，定时器可能再等待了2秒才触发，所以，检测到时间变动的秒数并不局限于1秒。

#### 误差

因为是秒级倒计时，所以，误差最大是999ms。假如当系统时间是1.999s的时候，定时器启动了，定时器会很快就检测到系统时间跳跃到2s，即检测到系统时间跳动了1秒，而实际上真正过去的时间并不到1秒。  
而因为定时器自身也并不精确，所以，本来误差是999ms，但是定时器可能也延时几百毫秒，所以，真正的误差可能缩减到几百毫秒以内。换言之，每次定时器触发，显示倒计时，显示的时间和实际的时间的误差是每次都不同的，每次都变化的，有时看起来“跳”得快，有时看起来“跳”得慢。但纵观整个倒计时过程，倒计的时间和流逝的时间是几乎相等的。